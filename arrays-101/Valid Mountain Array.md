## Valid Mountain Array

### 1. 문제 요약
주어진 정수 배열이 특정 지점(정상)까지는 증가다가, 그 이후부터 끝까지는 감소하는 배열인지 판별하는 문제.

### 2. 초기 접근 및 풀이

#### 핵심 로직

- 고민을 많이 했는데 풀이법을 모르겠다.
- 주말에 다시 풀어봐야지...

#### 초기 코드
```python
# 여기에 처음 작성했던 코드를 붙여넣습니다.
```

#### 복잡도 분석

- 시간 복잡도:
- 공간 복잡도:

### 3. 피드백 및 개선점
(내 풀이의 비효율적인 부분이나 개선할 점을 작성합니다.)

### 4. 최적화된 풀이

#### 개선된 로직

1. 오르막길 걷기
2. 정상 확인
3. 내리막길 걷기
4. 최종 도착 확인

위 과정을 풀어나가면 된다.

#### 최종 코드

```python
n = len(arr)

# 기본조건: 산은 길이가 3 이상이어야 한다
if n < 3:
    return False

i = 0

# 2. 오르막길 걷기
while i + 1 < n and arr[i] < arr[i+1]:
    i += 1

# 3. 정상 확인
if i == 0 or i == n-1:
    return False

# 4. 내리막길 걷기
while i + 1 < n and arr[i] > arr[i+1]:
    i += 1

# 5. 최종 도착 확인
return i == n - 1
```

#### 복잡도 분석

- 시간 복잡도: O(N)
- 공간 복잡도: O(1)

### 5. 핵심 정리 및 주요 원칙

#### 핵심 정리

하나의 포인터를 등산객처럼 생각하여, 오르막길이 끝날 때까지 전진하고, 이어서 내리막이 끝날때까지 전진시킨 후, 최종 위치가 배열의 맨 끝인지 확인하여 산 모양을 판별하는 것.