## Remove Element

### 1. 문제 요약
주어진 배열 nums에서 특정 값 val과 일치하는 모든 원소를 제자리에서(in-place) 제거하고, 그 결과로 남는 원소들의 개수(새로운 길이)를 반환하는 문제

### 2. 초기 접근 및 풀이

#### 핵심 로직
값이 val과 다를 때 덮어 씌우는 방식으로 풀었다.

#### 초기 코드
```python
class Solution:
    def removeElement(self, nums: List[int], val: int) -> int:
        i = 0
        for j in range(len(nums)):
            if nums[j] != val:
                nums[i] = nums[j]
                i += 1
        return i
```

#### 복잡도 분석

- 시간 복잡도: O(N)
- 공간 복잡도: O(1)


#### 핵심 정리
새로운 배열을 만들지 않고, '느린 포인터'를 사용하여 유효한 값들만 배열의 앞부분으로 꾹꾹 눌러 담듯이 덮어쓰는 것

#### 주요 원칙
1. 투 포인터 (Two Pointers): 역할이 다른 두 개의 포인터를 사용
    - 빠른 포인터 (j): 전체 배열을 빠짐없이 순회하며 현재 값을 탐색하는 역할.
    - 느린 포인터 (i): 유효한 값(val이 아닌 값)이 다음에 채워져야 할 위치를 가리키는 역할.

2. 제자리 덮어쓰기 (In-place Overwrite): 실제 원소를 '삭제'하는 것이 아니라, 불필요한 원소(val)가 있던 자리를 필요한 원소로 '덮어쓰는' 방식으로 문제를 해결. 이는 메모리 사용을 최적화하는 핵심 기법.
3. 느린 포인터 = 길이 카운터: 루프가 종료된 후, 느린 포인터(i)의 최종 값은 0부터 시작하여 유효한 값이 발견될 때마다 1씩 증가했으므로, 자연스럽게 새로운 배열의 길이(즉, 유효한 원소의 개수)와 일치하게 된다.