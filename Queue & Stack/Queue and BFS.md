## [Queue and BFS]

### 1. 큐: 줄 서기

- 핵심 원리: FIFO (First in, First-out). 먼저 들어온 것이 먼저 나간다.
- 동작: `enqueue` (줄 서기), `dequeue` (차례가 되어 나가기)
- 목적: 들어온 순서대로 작업을 처리할 때 사용한다.

### 2. 너비 우선 탐색 (BFS): 물결처럼 퍼져나가기

- 핵심 원리: 시작점에서 가장 가까운 노드부터 순서대로, 점차 거리를 넓혀가며 탐색하는 방법.
- 목표: 주로 최단 결로를 찾는 문제에 사용된다. 시작점에서 목표 지점까지 가장 적은 단계를 거쳐 가는 길을 찾을 때 매우 강력하다.

### 3. 둘의 관계: 왜 BFS는 큐를 사용할까?

큐의 FIFO 특징이 BFS의 "가까운 곳부터 탐색한다"는 원리를 완벽하게 구현해주기 때문이다.

탐색 과정을 따라가보자.

1. 시작: 시작 노드(거리 0)를 큐에 넣는다.
    - `Queue: [시작노드]`
2. 1단계: 큐에서 시작 노드를 꺼낸다. 그리고 시작 노드와 직접 연결된 모든 이웃(거리 1)들을 큐에 넣는다.
    - `Queue: [이웃A, 이웃B, 이웃C]`
3. 2단계: 이제 큐에서 이웃A를 꺼낸다. 그리고 이웃A와 연결된 모든 이웃(거리 2)들을 큐에 넣는다. 그 다음 이웃B를 꺼내고, 그 이웃들을 넣는다.
    - `Queue: [이웃C, A의이웃1, A의이웃2, B의이웃1, ...]`

결과적으로, 큐에 먼저 들어간 거리 1짜리 노드들이 모두 처리된 후에야, 그 다음에 들어간 거리 2짜리 노드들이 처리될 차례가 온다.
이런식으로 큐는 자연스럽게 탐색 순서를 거리 0 -> 거리 1 -> 거리 2 -> ... 순으로 만들어준다.

### BFS의 기본 템플릿

```py
from collections import deque

def bfs(start_node):
    # 1. 큐를 만들고 시작 노드를 넣는다.
    queue = deque([start_node])
    # 2. 방문 기록부를 만든다.
    visited = {start_node}

    # 3. 큐가 빌 때까지 반복한다.
    while queue:
        # 4. 큐에서 노드를 하나 꺼낸다.
        current_node = queue.popleft()

        # (여기서는 원하는 작업을 수행)
        print(current_node)

        # 5. 꺼낸 노드의 모든 이웃을 확인한다.
        for neighbor in current_node.neighbors:
            # 6. 아직 방문하지 않은 이웃이라면,
            if neighbor not in visited:
                # 방문 기록을 남기고 큐에 넣는다.
                visited.add(neighbor)
                queue.append(neighbor)
```

