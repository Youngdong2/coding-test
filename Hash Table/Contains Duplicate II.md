## Contains Duplicate II

### 1. 문제 요약

주어진 정수 배열에서 동일한 값을 가진 두 원소의 인덱스 차이가 특정 정수 k보다 작거나 같은 경우가 있는지 판별하는 문제

### 2. 초기 접근 및 풀이

#### 핵심 로직

- 딕셔너리를 만들고 값과 인덱스를 저장한다.
- 배열을 돌며 값이 딕셔너리에 있다면 조건과 확인하고 조건에 안맞으면 인덱스를 업데이트해준다.

#### 초기 코드
```python
class Solution:
    def containsNearbyDuplicate(self, nums: List[int], k: int) -> bool:
        mapping = {}
        for i in range(len(nums)):
            if nums[i] not in mapping:
                mapping[nums[i]] = i
                
            else:
                if abs(mapping[nums[i]] - i) <= k:
                    return True
                
                else:
                    mapping[nums[i]] = i
                    
        return False
```

#### 복잡도 분석

- 시간 복잡도: O(N)
- 공간 복잡도: O(min(N, K))

### 3. 피드백 및 개선점

- 제미나이 왈: 결론부터 말씀드리면, 이 코드는 문제를 해결하는 가장 이상적이고 효율적인, 완벽한(Perfect) 정답입니다. 한마디로, 이 코드는 더 이상 개선할 점이 없는 교과서적인 모범 답안입니다.


### 5. 핵심 정리 및 주요 원칙

#### 핵심 정리

배열을 한 번만 순회하면서, 해시맵(딕셔너리)에 각 숫자의 '가장 최근에 등장한 위치'를 계속 기록하고 갱신하며, 중복된 숫자를 만날 때마다 저장된 위치와의 거리가 k 이내인지 즉시 확인하는 것

#### 주요 원칙

1. 해시맵을 이용한 인덱스 추적: 해시맵을 {숫자: 가장 최근에 등장한 인덱스} 형태로 사용하여, 특정 숫자의 가장 가까운 이전 위치 정보를 O(1)의 빠른 속도로 조회합니다.
2. 원 패스 선형 탐색 (One-Pass): 이중 for 루프를 피하고, 단 한 번의 순회로 문제를 해결하여 시간 복잡도를 O(N)으로 최적화합니다.
3. '가장 가까운' 인덱스 갱신: 중복된 숫자를 발견했지만 거리가 k보다 멀 경우, 앞으로의 비교를 위해 해시맵에 저장된 인덱스를 현재의 '더 가까운' 인덱스로 갱신합니다. 이를 통해 항상 가장 최근 등장 위치와의 거리만을 효율적으로 비교할 수 있습니다.